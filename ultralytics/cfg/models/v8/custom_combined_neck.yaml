nc: 3
ch: [3]

backbone:
  - [-1, 1, DWSConv, [32, 3, 2]]         # 0: Stem
  - [-1, 1, DWSConv, [48, 3, 2]]         # 1: Stage 1
  - [-1, 1, DWSConv, [64, 3, 2]]         # 2: Stage 2
  - [-1, 1, SE, [64]]                    # 3
  - [-2, 1, DWSConv, [128, 3, 2]]        # 4: Stage 3
  - [-1, 1, SE, [128]]                   # 5: C3
  - [-1, 1, CondConv, [256, 3, 2]]       # 6: Stage 4
  - [-1, 1, SE, [256]]                   # 7: C4
  - [-1, 1, DeformableConv, [512, 3, 2]] # 8: Stage 5
  - [-1, 1, CBAM, [512]]                 # 9
  - [-1, 1, DeformableConv, [512, 3, 1]] # 10: Stage 6
  - [-1, 1, CBAM, [512]]                 # 11: C5

# ----------------------
# Custom Neck (Optimized for Your Backbone)
# ----------------------
head :
  # ---- Stage 1: Channel Reduction ----
  # Inputs: C3 (40x40,128), C4 (20x20,256), C5 (10x10,512)
  - [5, 1, DWSConv, [128, 1, 1]]       # 12: C3 → 128 ch (P3)
  - [7, 1, DWSConv, [128, 1, 1]]       # 13: C4 → 128 ch (P4)
  - [11, 1, DWSConv, [128, 1, 1]]      # 14: C5 → 128 ch (P5)

  # ---- Stage 2: Bottom-Up Mixing (C5 → C4 → C3) ----
  # Mix C5 into C4 (no upsample! Strided conv instead)
  - [14, 1, DWSConv, [128, 3, 2]]      # 15: C5 (10x10→20x20, 128 ch)
  - [[13, 15], 1, nn.Add, []]           # 16: C4 + C5 → Mixed P4

  # Mix result into C3 (again, strided conv)
  - [16, 1, DWSConv, [128, 3, 2]]      # 17: Mixed P4 (20x20→40x40, 128 ch)
  - [[12, 17], 1, nn.Add, []]           # 18: C3 + Mixed P4 → Final P3

  # ---- Stage 3: Top-Down Refinement ----
  # Optional: Refine P4 by mixing P3 back down (lightweight)
  - [18, 1, DWSConv, [128, 3, 2]]      # 19: P3 (40x40→20x20, 128 ch)
  - [[16, 19], 1, nn.Add, []]           # 20: Mixed P4 + P3 → Final P4

  # Outputs: P3 (40x40,128), P4 (20x20,128), P5 (10x10,128)
  - [[18, 20, 14], 1, Detect, [nc]]    # 21: Detect layer

